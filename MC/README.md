# O2DPG - Monte Carlo Simulation

Withing this directory structure are located the scripts and configuration to run Monte Carlo simulations of the ALICE experiment within the O2 project.

## Adding QC Tasks to the simulation script

Below are the steps to integrate a new QC Task to the main simulation, reco and QC workflow.

1. Build O2, QualityControl, O2Physics and O2DPG with `o2` defaults:
```
aliBuild build O2 QualityControl O2Physics O2DPG --defaults o2 -j <jobs>
```

2. (Optional) Make sure that the setup works by loading the environment and running the example script.
It runs a series of tasks, which are usually DPL workflows that depend on each other and write/read processing results in form of ROOT files.
It will simulate 3 TimeFrames, reconstruct them and run any QC.
Corresponding files will be created in the current directory, QC objects will be also uploaded to QCDB. 
```
alienv enter O2/latest O2Physics/latest QualityControl/latest O2DPG/latest
cd MC/run/examples
./O2DPG_pp_minbias_multiple_tf_qc.sh
```
If the script does not succeed, contact the repository maintainers.
Sometimes an intermittent issue might appear, then it might be worth executing the script again - it will pick up from the latest failed task.

3. Prepare a QC config file of your Task.
Please make sure to put the following default parameters in the Activity section:
```
     "Activity": {
       ...
       "provenance": "qc_mc",
       "passName": "passMC",
       "periodName": "SimChallenge"
     },

```
With the future developments, they will be overwritten with production-specific values.
Also, since the processing time is not critical, one can avoid using data sampling in most cases and use "direct" data sources (see QC doc)

Put the file to MC/config/QC/json directory or make sure it is installed in the QC package.

4. In `o2dpg_sim_workflow.py`, find the big loop over simulated TimeFrames and the QC section within.
Add your QC following the example below.
See the explanation of particular lines for more information.
```
for tf in range(1, NTIMEFRAMES + 1):
  ...
  if includeFullQC or includeLocalQC:
    ...
    ### Primary vertex
    addQCPerTF(taskName='vertexQC',
               needs=[PVFINDERtask['name']], # defines which tasks should run before this QC workflow, so the relevant results are available
               readerCommand='o2-primary-vertex-reader-workflow', # defines what command should be used to read input files and put before o2-qc workflow
               configFilePath='json://${O2DPG_ROOT}/MC/config/QC/json/vertexing-qc-direct-mc.json') # path to the QC config file
```
The lines above will make the QC task ran for each simulated and reconstructed timeframe separately.
The intermediate results will be stored and merged in one file in the `QC` directory.

5. Open the `o2dpg_qc_finalization_workflow.py` script and find the `include_all_QC_finalization` function.

This part makes the later parts of QC (Checks, Aggregators, uploading to QCDB) run after all TimeFrames are processed.
Add your QC following the example below. Use the same task name and config file as in the previous point.
```
def include_all_QC_finalization(ntimeframes, standalone):
  ...
  add_QC_finalization('vertexQC', 'json://${O2DPG_ROOT}/MC/config/QC/json/vertexing-qc-direct-mc.json')

```

6. Delete the files generated by the workflow during step 2 and run the `O2DPG_pp_minbias_multiple_tf_qc.sh` script again.
Verify that the QC Task succeeds.
You can run only the parts of the workflow which are required to reach your QC task by adding `-tt <task_name>_finalize` to `o2_dpg_workflow_runner.py`.
Logs are available under task names in their working directories: tf<n> when processing TFs and QC during finalization.

7. Ask Catalin to add the file with QC results to the list of merged files on Grid productions. The file has the same name as `taskName`, but with the `.root` suffix. If you update the task name, also please let Catalin know.

## Adding QC post-processing tasks to the simulation script

One can execute a QC post-processing workflow as the last stage of QC.
To do that, please follow the points below.

1. Similarly to the points 1-3 in the previous chapter, verify that you can run the workflow before making changes.
Prepare the QC config file, putting correct values in the `Activity` section.
Pay attention to set applicable triggers in the post-processing task, see the [QC doc](https://github.com/AliceO2Group/QualityControl/blob/master/doc/PostProcessing.md#more-examples) for relevant examples.
Most likely, you will need to use either `ForEachObject` or `ForEachLatest` triggers.

2. In `o2dpg_qc_finalization_workflow.py`, find the `include_all_QC_finalization` function.

Add your QC post-processing workflow there using the `add_QC_postprocessing` function.
See its in-code documentation for argument explanation and follow the existing examples.
Please make sure to set the correct `needs`, so the post-processing workflow is executed only when the required QC objects are already in the QCDB.

3. Delete the files generated by the workflow during the previous steps and run the `O2DPG_pp_minbias_multiple_tf_qc.sh` script again.
Verify that the QC post-processing workflow succeeds.
You can run only the parts of the workflow which are required to reach your QC task by adding `-tt <task_name>_finalize` to `o2_dpg_workflow_runner.py`.
Relevant logs are available under task names in the `QC` directory.

